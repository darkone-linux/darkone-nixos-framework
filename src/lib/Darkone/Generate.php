<?php

namespace Darkone;

use Darkone\MdxGenerator\Generator;
use Darkone\NixGenerator\Configuration;
use Darkone\NixGenerator\Item\Host;
use Darkone\NixGenerator\NixBuilder;
use Darkone\NixGenerator\NixException;
use Darkone\NixGenerator\Token\NixAttrSet;
use Darkone\NixGenerator\Token\NixList;
use UnhandledMatchError;

class Generate
{
    private const FILE_GEN_DISKO_FLAKE = NIX_PROJECT_ROOT . '/var/generated/disko/flake.nix';
    private const FILE_GEN_DISKO_CONFIG = NIX_PROJECT_ROOT . '/var/generated/disko/configuration.nix';
    private const FILE_GEN_DISKO_INSTALL_TPL = NIX_PROJECT_ROOT . '/var/generated/disko/install-{{host}}.nix';
    private const FILE_GEN_DISKO_FILE = NIX_PROJECT_ROOT . '/usr/machines/{{host}}/disko.nix';
    private const FILE_GEN_CONF_FILE = NIX_PROJECT_ROOT . '/usr/machines/{{host}}/generated-configuration.nix';
    private const FILE_GEN_NETWORK = NIX_PROJECT_ROOT . '/var/generated/network.nix';
    private const FILE_GEN_HOSTS = NIX_PROJECT_ROOT . '/var/generated/hosts.nix';
    private const FILE_GEN_USERS = NIX_PROJECT_ROOT . '/var/generated/users.nix';
    private const FILE_CPY_MACHINE_DEFAULT_SRC = NIX_PROJECT_ROOT . '/dnf/hosts/templates/usr-machines-default.nix';
    private const FILE_CPY_MACHINE_DEFAULT_DST = NIX_PROJECT_ROOT . '/usr/machines/{{host}}/default.nix';
    private const FILE_HRD_MACHINE_EMPTY = NIX_PROJECT_ROOT . '/usr/machines/{{host}}/hardware-configuration.nix';

    private const FILE_MAIN_FLAKE = NIX_PROJECT_ROOT . '/flake.nix';
    private const FILE_HOST_TPL_INSTALL = NIX_PROJECT_ROOT . '/dnf/hosts/templates/install.nix';

    private const GEN_FILE_HEADER = "# This file is generated by 'just generate' or 'just clean'\n# from the configuration file usr/config.yaml\n# --> DO NOT EDIT <--\n\n";

    private Configuration $config;

    /**
     * @throws NixException
     */
    public function __construct(string $yamlConfigFile, string $yamlGeneratedConfigFile)
    {
        if (!defined('NIX_PROJECT_ROOT')) {
            throw new NixException('NIX_PROJECT_ROOT must be defined');
        }
        $this->config = (new Configuration())->loadYamlFiles($yamlConfigFile, $yamlGeneratedConfigFile);
    }

    /**
     * @throws NixException
     */
    public function generate(string $what, bool $display = false): string
    {
        try {
            return match ($what) {
                'hosts' => $this->generateHosts($display),
                'users' => $this->generateUsers($display),
                'network' => $this->generateNetworkConfig($display),
                'disko' => $this->generateDisko($display),
                'doc' => $this->generateDoc($display)
            };
        } catch (UnhandledMatchError) {
            throw new NixException('Unknown item "' . $what . '", unable to generate');
        }
    }

    /**
     * Generate the hosts.nix file loaded by flake.nix
     * @throws NixException
     */
    private function generateHosts(bool $display): string
    {
        $hosts = new NixList();
        foreach ($this->config->getHosts() as $host) {
            $deployment = (new NixAttrSet())
                ->set('tags', (new NixList())->populateStrings($this->extractTags($host)));
            $colmena = (new NixAttrSet())->set('deployment', $deployment);
            $newHost = (new NixAttrSet())
                ->setString('hostname', $host->getHostname())
                ->setString('name', $host->getName())
                ->setString('profile', $host->getProfile())
                ->setString('ip', $host->getIp())
                ->setString('arch', $host->getArch())
                ->set('groups', (new NixList())->populateStrings($host->getGroups()))
                ->set('users', (new NixList())->populateStrings($host->getUsers()))
                ->set('colmena', $colmena)
                ->set('services', NixBuilder::arrayToNix($host->getServices()));
            $hosts->add($newHost);
        }

        return $this->registerContent(self::FILE_GEN_HOSTS, $hosts, $display);
    }

    /**
     * Generate the hosts.nix file loaded by flake.nix
     * @throws NixException
     */
    private function generateUsers(bool $display): string
    {
        $users = new NixAttrSet();
        foreach ($this->config->getUsers() as $user) {
            $users->set($user->getLogin(), (new NixAttrSet())
                ->setInt('uid', $user->getUid())
                ->setString('email', $user->getEmail())
                ->setString('name', $user->getName())
                ->setString('profile', $user->getProfile())
                ->set('groups', (new NixList())->populateStrings($user->getGroups())));
        }

        return $this->registerContent(self::FILE_GEN_USERS, $users, $display);
    }

    private function extractTags(Host $host): array
    {
        return array_merge(
            $host->getTags(),
            array_map(fn (string $group): string => 'group-' . $group, $host->getGroups()),
            array_map(fn (string $user): string => 'user-' . $user, array_filter($host->getUsers(), fn (string $user): bool => $user !== 'nix'))
        );
    }

    /**
     * Generate the hosts.nix file loaded by flake.nix
     * @throws NixException
     */
    private function generateNetworkConfig(bool $display): string
    {
        return $this->registerContent(self::FILE_GEN_NETWORK, NixBuilder::arrayToNix($this->config->getNetworkConfig()), $display);
    }

    /**
     * Generate and write host disko profiles
     * @throws NixException
     */
    private function generateDisko(bool $display): string
    {
        if (!$display) {
            $dir = dirname(self::FILE_GEN_DISKO_CONFIG);
            shell_exec('rm -f ' . escapeshellarg($dir . '/') . '*.nix');
            self::mkdir($dir);
        }
        return $this->generateDiskoConfig($display) . $this->generateFlakeAndInstalls($display);
    }

    /**
     * @throws NixException
     */
    public function generateDiskoConfig(bool $display): string
    {
        $installTpl = trim(preg_replace(
            ["/ *#[^\n]*\n/", "/ *\n */"],
            ['', ' '],
            file_get_contents(self::FILE_HOST_TPL_INSTALL)
        ));
        preg_match(
            '/^.*unstableStateVersion *= *"([0-9][0-9]\.[0-9][0-9])".*$/m',
            file_get_contents(self::FILE_MAIN_FLAKE),
            $flakeMatches
        );
        if (!isset($flakeMatches[1])) {
            throw new NixException("Unable to find current unstable state version");
        }
        return $this->registerContent(self::FILE_GEN_DISKO_CONFIG, str_replace(['{{nixPubKey}}', '{{gateway}}', '{{currentStateVersion}}'], [
            trim(file_get_contents(NIX_PROJECT_ROOT . '/usr/secrets/nix.pub')),
            $this->config->getNetworkConfig()['gateway']['hostname'],
            $flakeMatches[1]
        ], $installTpl), $display, true);
    }

    public function generateFlakeAndInstalls(bool $display): string
    {
        $stream = '';
        $flake = '{nixConfig.extra-substituters=["http://gateway:8501"];inputs={nixpkgs.url="github:NixOS/nixpkgs/nixpkgs-unstable";'
            . 'disko.url="github:nix-community/disko";'
            . 'disko.inputs.nixpkgs.follows="nixpkgs";};'
            . 'outputs={nixpkgs,disko,...}:{nixosConfigurations={';
        foreach ($this->config->getHosts() as $host) {
            $disko = $host->getDisko();
            if (empty($disko['profile'])) {
                continue;
            }

            // var/generated/disko/install-<host>.nix
            $machineConfig = './../../../usr/machines/' . $host->getHostname();
            $fileContent = '{lib,...}:{imports=[' . $machineConfig . '];';
            $fileContent .= 'networking.hostName="' . $host->getHostname() . '";';
            $file = str_replace('{{host}}', $host->getHostname(), self::FILE_GEN_DISKO_INSTALL_TPL);
            $stream .= $this->registerContent($file, $fileContent . "}", $display, true);

            // usr/machines/<host>/default.nix
            // Only if not exists
            $defaultMachineFilename = str_replace('{{host}}', $host->getHostname(), self::FILE_CPY_MACHINE_DEFAULT_DST);
            $display || self::mkdir(dirname($defaultMachineFilename));
            $display || file_exists($defaultMachineFilename) || copy(
                self::FILE_CPY_MACHINE_DEFAULT_SRC,
                $defaultMachineFilename
            );

            // usr/machines/<host>/hardware-configuration.nix
            // Only if not exists
            // This file is reinitialized and regenerated by the "just install" process
            $hardwareMachineFilename = str_replace('{{host}}', $host->getHostname(), self::FILE_HRD_MACHINE_EMPTY);
            $display || file_exists($hardwareMachineFilename) || file_put_contents($hardwareMachineFilename, '{}');

            // usr/machines/<host>/disko.nix
            // Only if not exists
            $diskoSourceFile = NIX_PROJECT_ROOT . '/' . $disko['profile'];
            $diskoFilename = str_replace('{{host}}', $host->getHostname(), self::FILE_GEN_DISKO_FILE);
            $display || file_exists($diskoFilename) || copy($diskoSourceFile, $diskoFilename);

            // usr/machines/<host>/generated-configuration.nix
            // Force generate if exists
            $generatedConfFilename = str_replace('{{host}}', $host->getHostname(), self::FILE_GEN_CONF_FILE);
            $generatedConf = '{config,lib,...}:{';
            foreach ($disko['devices'] ?? [] as $name => $device) {
                $generatedConf .= 'disko.devices.disk.' . $name . '.device=lib.mkForce "' . $device . '";';
            }
            $diskoStream = file_get_contents($diskoFilename);
            if (str_contains($diskoStream, 'type = "mdadm";')) {
                $generatedConf .= "boot.swraid.enable = lib.mkForce true;";
            }
            if (preg_match('/^.*NEEDEDFORBOOT:(.+)\n.*$/m', $diskoStream, $matches)) {
                foreach (explode(';', $matches[1]) as $partition) {
                    $generatedConf .= 'fileSystems."' . $partition . '".neededForBoot=lib.mkForce true;';
                }
            }
            $this->registerContent($generatedConfFilename, $generatedConf . '}', $display, true);

            // var/generated/disko/flake.nix
            $flake .= $host->getHostname() . '=nixpkgs.lib.nixosSystem{system="'
                . ($host->getArch() ?: 'x86_64-linux')
                . '";modules=[disko.nixosModules.disko ./configuration.nix ./install-'
                . $host->getHostname() . '.nix'
                . '];};';
        }
        $stream .= $this->registerContent(self::FILE_GEN_DISKO_FLAKE, $flake . "};};}", $display, true);

        return $stream;
    }

    private function generateDoc(bool $debug): string
    {
        $debug || Generator::generateAll();
        return $debug ? "No debug mode for documentation generation.\n" : '';
    }

    private function registerContent(
        string $targetFile,
        string $content,
        bool $display,
        bool $decorateWithFile = false
    ): string {
        if ($display) {
            return $decorateWithFile ? basename($targetFile, '.nix') . ' ' . $content . "\n" : $content;
        }

        file_put_contents($targetFile, self::GEN_FILE_HEADER . $content);
        ob_start();
        passthru($this->config->getFormatter() . ' -sv ' . escapeshellarg($targetFile) . ' 2>&1');
        $errors = trim(ob_get_clean());
        if ($errors != '') {
            echo "\n  [NIX SYNTAX ERROR] " . $targetFile . "\n\n";
            echo $errors . "\n";
            die(1);
        }

        return '';
    }

    private static function mkdir(string $dir): void
    {
        is_dir($dir) || mkdir($dir, 0750, true);
    }
}
