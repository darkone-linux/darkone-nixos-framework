<?php

namespace Darkone;

use Darkone\MdxGenerator\Generator;
use Darkone\MdxGenerator\MdxException;
use Darkone\NixGenerator\Configuration;
use Darkone\NixGenerator\Item\Host;
use Darkone\NixGenerator\Item\User;
use Darkone\NixGenerator\NixBuilder;
use Darkone\NixGenerator\NixException;
use Darkone\NixGenerator\Token\NixAttrSet;
use Darkone\NixGenerator\Token\NixList;
use UnhandledMatchError;

class Generate
{
    private const string FILE_GEN_DISKO_FILE = NIX_PROJECT_ROOT . '/usr/machines/{{host}}/disko.nix';
    private const string FILE_GEN_CONF_FILE = NIX_PROJECT_ROOT . '/usr/machines/{{host}}/generated-configuration.nix';
    private const string FILE_GEN_NETWORK = NIX_PROJECT_ROOT . '/var/generated/network.nix';
    private const string FILE_GEN_HOSTS = NIX_PROJECT_ROOT . '/var/generated/hosts.nix';
    private const string FILE_GEN_USERS = NIX_PROJECT_ROOT . '/var/generated/users.nix';
    private const string FILE_CPY_MACHINE_DEFAULT_SRC = NIX_PROJECT_ROOT . '/dnf/hosts/templates/usr-machines-default.nix';
    private const string FILE_CPY_MACHINE_DEFAULT_DST = NIX_PROJECT_ROOT . '/usr/machines/{{host}}/default.nix';
    private const string FILE_HRD_MACHINE_EMPTY = NIX_PROJECT_ROOT . '/usr/machines/{{host}}/hardware-configuration.nix';

    private const string FILE_MAIN_FLAKE = NIX_PROJECT_ROOT . '/flake.nix';

    private const string GEN_FILE_HEADER = "# This file is generated by 'just generate' or 'just clean'\n# from the configuration file usr/config.yaml\n# --> DO NOT EDIT <--\n\n";

    private const string DIR_USR = NIX_PROJECT_ROOT . '/usr/users/{{user}}';

    /**
     * @var Configuration
     */
    private Configuration $config;

    /**
     * @param string $yamlConfigFile
     * @param string $yamlGeneratedConfigFile Generated by sops
     * @throws NixException
     */
    public function __construct(string $yamlConfigFile, string $yamlGeneratedConfigFile)
    {
        if (!defined('NIX_PROJECT_ROOT')) {
            throw new NixException('NIX_PROJECT_ROOT must be defined');
        }
        $this->config = (new Configuration())->loadYamlFiles($yamlConfigFile, $yamlGeneratedConfigFile);
    }

    /**
     * @throws NixException|MdxException
     */
    public function generate(string $what, bool $display = false): string
    {
        try {
            array_map(
                fn (string $name) => Configuration::assertUniqName($name, 'reserved word'),
                Configuration::RESERVED_NAMES
            );
            return match ($what) {
                'hosts' => $this->generateHosts($display),
                'users' => $this->generateUsers($display),
                'network' => $this->generateNetworkConfig($display),
                'disko' => $this->generateDisko($display),
                'doc' => $this->generateDoc($display)
            };
        } catch (UnhandledMatchError) {
            throw new NixException('Unknown item "' . $what . '", unable to generate');
        }
    }

    /**
     * Generate the hosts.nix file loaded by flake.nix
     * @throws NixException
     */
    private function generateHosts(bool $display): string
    {
        $hosts = new NixList();
        foreach ($this->config->getHosts() as $host) {
            $deployment = (new NixAttrSet())
                ->set('tags', (new NixList())->populateStrings($this->extractTags($host)));
            $colmena = (new NixAttrSet())->set('deployment', $deployment);
            $fqdn = (isset($this->config->getZones()[$host->getZone()]) && $host->getZone() !== Configuration::EXTERNAL_ZONE_KEY)
                ? $host->getHostname()
                    . '.' . $this->config->getZones()[$host->getZone()]->getName()
                    . '.' . $this->config->getNetwork()->getDomain()
                : $host->getHostname() . '.' . $this->config->getNetwork()->getDomain();
            Configuration::assertUniqName($host->getHostname(), 'host', $host->getZone());
            $newHost = (new NixAttrSet())
                ->setString('hostname', $host->getHostname())
                ->setString('zone', $host->getZone())
                ->setString('fqdn', $fqdn)
                ->setString('name', $host->getName())
                ->setString('profile', $host->getProfile())
                ->setString('ip', $host->getIp())
                ->setString('vpnIp', $host->getVpnIp())
                ->setString('arch', $host->getArch())
                ->setString('zoneDomain', $host->getZoneDomain())
                ->setString('networkDomain', $host->getNetworkDomain())
                ->set('groups', (new NixList())->populateStrings($host->getGroups()))
                ->set('features', $host->getFeatures())
                ->set('users', (new NixList())->populateStrings($host->getUsers()))
                ->set('colmena', $colmena)
                ->set('services', NixBuilder::arrayToNix($host->getServices()));
            $hosts->add($newHost);
        }

        return $this->registerContent(self::FILE_GEN_HOSTS, $hosts, $display);
    }

    /**
     * Generate the hosts.nix file loaded by flake.nix
     * @throws NixException
     */
    private function generateUsers(bool $display): string
    {
        $users = new NixAttrSet();
        foreach ($this->config->getUsers() as $user) {
            $users->set($user->getLogin(), (new NixAttrSet())
                ->setInt('uid', $user->getUid())
                ->setString('email', $user->getEmail())
                ->setString('name', $user->getName())
                ->setString('profile', $user->getProfile())
                ->set('groups', (new NixList())->populateStrings($user->getGroups())));
            $this->buildHome($user, $display);
        }

        return $this->registerContent(self::FILE_GEN_USERS, $users, $display);
    }

    /**
     * @param User $user
     * @param bool $display
     * @return void
     * @throws NixException
     */
    private function buildHome(User $user, bool $display): void
    {
        $usrDir = str_replace('{{user}}', $user->getLogin(), self::DIR_USR);
        is_dir($usrDir) || mkdir($usrDir);
        if (!file_exists($usrDir . '/default.nix')) {
            $content = '{pkgs,...}:{home.username="' . $user->getLogin() . '"; # DO NOT TOUCH!' . "\n";
            $content .= 'home.stateVersion="' . self::extractCurrentStateVersion() . '"; # DO NOT TOUCH!';
            $content .= "\n\n# Write here a specific configuration for current user\nhome.packages=with pkgs;[];}";
            $header = '# Specific home manager settings for user ' . $user->getLogin() . ' id:' . $user->getUid();
            $header .= ' (' . $user->getEmail() . ")\n\n";
            $this->registerContent($usrDir . '/default.nix', $content, $display, true, $header);
        }
    }

    /**
     * Auto-generated tags:
     * - group-*
     * - user-*
     * - zone-*
     */
    private function extractTags(Host $host): array
    {
        return array_merge(
            $host->getTags(),
            array_map(fn (string $group): string => 'group-' . $group, $host->getGroups()),
            array_map(fn (string $group): string => 'feature-' . $group, $host->getFeaturesKeys()),
            array_map(fn (string $user): string => 'user-' . $user, array_filter($host->getUsers(), fn (string $user): bool => $user !== 'nix')),
            ['zone-' . $host->getZone()],
        );
    }

    /**
     * Generate the hosts.nix file loaded by flake.nix
     * @throws NixException
     */
    private function generateNetworkConfig(bool $display): string
    {
        $networkServices = $this->config->getNetwork()->servicesToArray();
        return $this->registerContent(
            self::FILE_GEN_NETWORK, 
            NixBuilder::arrayToNix(
                $this->config->getNetworkConfig()
                + ['services' => empty($networkServices) ? new NixList() : $networkServices]
                + ['zones' => $this->config->extractZonesConfig()]
            ), $display
        );
    }

    /**
     * Generate and write host disko profiles
     */
    private function generateDisko(bool $display): string
    {
        $this->generateFlakeAndInstalls($display);
        return '';
    }

    /**
     * @return string
     * @throws NixException
     */
    public static function extractCurrentStateVersion(): string
    {
        static $flakeMatches = [];

        empty($flakeMatches) && preg_match(
            '/^.*unstableStateVersion *= *"([0-9][0-9]\.[0-9][0-9])".*$/m',
            file_get_contents(self::FILE_MAIN_FLAKE),
            $flakeMatches
        );
        if (!isset($flakeMatches[1])) {
            throw new NixException("Unable to find current unstable state version");
        }

        return $flakeMatches[1];
    }

    /**
     * @param bool $display
     */
    public function generateFlakeAndInstalls(bool $display): void
    {
        foreach ($this->config->getHosts() as $host) {
            $disko = $host->getDisko();
            if (empty($disko['profile'])) {
                continue;
            }

            // usr/machines/<host>/default.nix
            // Only if not exists
            $defaultMachineFilename = str_replace('{{host}}', $host->getHostname(), self::FILE_CPY_MACHINE_DEFAULT_DST);
            $display || self::mkdir(dirname($defaultMachineFilename));
            $display || file_exists($defaultMachineFilename) || copy(
                self::FILE_CPY_MACHINE_DEFAULT_SRC,
                $defaultMachineFilename
            );

            // usr/machines/<host>/hardware-configuration.nix
            // Only if not exists
            // This file is reinitialized and regenerated by the "just install" process
            $hardwareMachineFilename = str_replace('{{host}}', $host->getHostname(), self::FILE_HRD_MACHINE_EMPTY);
            $display || file_exists($hardwareMachineFilename) || file_put_contents($hardwareMachineFilename, '{}');

            // usr/machines/<host>/disko.nix
            // Only if not exists
            $diskoSourceFile = NIX_PROJECT_ROOT . '/' . $disko['profile'];
            $diskoFilename = str_replace('{{host}}', $host->getHostname(), self::FILE_GEN_DISKO_FILE);
            $display || file_exists($diskoFilename) || copy($diskoSourceFile, $diskoFilename);

            // usr/machines/<host>/generated-configuration.nix
            // Force generate if exists
            $generatedConfFilename = str_replace('{{host}}', $host->getHostname(), self::FILE_GEN_CONF_FILE);
            $generatedConf = '{config,lib,...}:{';
            foreach ($disko['devices'] ?? [] as $name => $device) {
                $generatedConf .= 'disko.devices.disk.' . $name . '.device=lib.mkForce "' . $device . '";';
            }
            $diskoStream = file_get_contents($diskoFilename);
            if (str_contains($diskoStream, 'type = "mdadm";')) {
                $generatedConf .= "boot.swraid.enable = lib.mkForce true;";
            }
            if (preg_match('/^.*NEEDEDFORBOOT:(.+)\n.*$/m', $diskoStream, $matches)) {
                foreach (explode(';', $matches[1]) as $partition) {
                    $generatedConf .= 'fileSystems."' . $partition . '".neededForBoot=lib.mkForce true;';
                }
            }
            $this->registerContent($generatedConfFilename, $generatedConf . '}', $display, true);
        }
    }

    /**
     * @param bool $debug
     * @return string
     * @throws MdxException
     */
    private function generateDoc(bool $debug): string
    {
        return Generator::generateAll($debug);
    }

    /**
     * @param string $targetFile
     * @param string $content
     * @param bool $display
     * @param bool $decorateWithFile
     * @param string|null $header
     * @return string
     */
    private function registerContent(
        string $targetFile,
        string $content,
        bool $display,
        bool $decorateWithFile = false,
        ?string $header = null
    ): string {
        if ($display) {
            return $decorateWithFile ? basename($targetFile, '.nix') . ' ' . $content . "\n" : $content;
        }

        file_put_contents($targetFile, ($header ?: self::GEN_FILE_HEADER) . $content);
        ob_start();
        passthru($this->config->getFormatter() . ' -sv ' . escapeshellarg($targetFile) . ' 2>&1');
        $errors = trim(ob_get_clean());
        if ($errors != '') {
            echo "\n  [NIX SYNTAX ERROR] " . $targetFile . "\n\n";
            echo $errors . "\n";
            die(1);
        }

        return '';
    }

    /**
     * @param string $dir
     * @return void
     */
    private static function mkdir(string $dir): void
    {
        is_dir($dir) || mkdir($dir, 0750, true);
    }
}
